# python_huffman
Repo for the huffman compression algorithm activity for the analysis of algorithms class at Universidad de Guadalajara, CUCEI.
Code has a front-end made in Tkinter, using the tkinter and numpy libraries.
The front end lets any user connect it to a personal back-end, as long as they link the back-end functions to the interface's buttons.
Front-end is fully implemented in a single file, containing a class named Interface and all its methods fairly commented and explained as well as some attributes.
The interface provides a simple window with a text frame and 3 buttons, one for opening files (only supports txt and binary extensions)
and 2 other buttons for either compressing or decompressing depending on the extension of the selected file
If the selected file is a txt file, the interface counts the characters, builds and sorts a dictionary stored as an attribute called char_count.
If the selected file the interface just stores the content of the file in the file_content variable.
The idea is that the back-end functions have parameters for receiving a dictionary (for the compression of txt files) or just a string (the compressed binary file)
After receiving those arguments, they can operate and make the compression or decompression internally, and possibly return a file or just a string for interface to show.

# Desarrollo (español)
Para la implementación del front-end se utilizó la librería tkinter de Python, esta permite realizar interfaces graficas de manera simple e intuitiva una vez se conoce la implementación de sus clases y métodos, a pesar de esto, puede resultar un poco pobre para programas muy extensos o complejos, en cuyo caso se recomienda utilizar alternativas mas capaces como lo podría ser PyQT, en nuestro caso debido a la simplicidad del problema, tkinter presento ser una opción bastante factible.
Para integrar la funcionalidad de Tkinter se tiene una clase titulada Interface la cual se encarga de generar la instancia de la interfaz, también permite establecer algunos atributos desde el inicializador, como el largo y ancho de la interfaz, establecidos como 640x480 por default, así como el titulo de nuestra ventana, que tiene por default “Huffman Algorithm Interface”.
Además de esto, en el inicializador también se definen los atributos mas importantes para el funcionamiento de la interfaz, como lo es el contenido del archivo (file_content), el diccionario para la cuenta de caracteres (char_count) y un texto que se mostrara en un widget de la interfaz.
El inicializador hace llamada de dos métodos auxiliares, uno para ajustar las dimensiones de la interfaz con los mismos argumentos que se reciben para el constructor de la clase, este toma las dimensiones proporcionadas y consigue el tamaño de la pantalla donde se muestra la interfaz haciendo uso de métodos de tkinter winfo_screenwidth y winfo_screenheight para calcular la posición x y y donde debe mostrarse la interfaz para que este centrada para finalmente hacer uso del método geometry de la interfaz donde se establecen las dimensiones de ancho y alto así como la posición x y y de la interfaz.
El otro método auxiliar que utiliza el inicializador es el de generar elementos, donde se generan elementos para la interfaz, como la etiqueta del algoritmo, un marco, un widget de texto con una scrollbar y los 3 botones que se requerirán para el funcionamiento del programa; examinar, descomprimir y comprimir. El marco mostrara lo que tengamos establecido en el widget de texto, originalmente se pensaba mostrar el contenido del archivo pero después se cambio por que se mostrara el diccionario de caracteres. Los botones de descomprimir y comprimir están deshabilitados por default, y se habilitaran únicamente si se ha abierto un archivo correspondiente a la función de cada botón, es decir, se habilita el botón de compresión si se abre un archivo de texto y se habilita el archivo de descompresión si se abre un archivo binario comprimido.
El botón de examinar hará llamada de un método abrir archivo, este a su vez deshabilita los botones de compresión y decompresion (en caso de que se hubieran habilitado previamente por un archivo abierto) y se limpia el contenido de la variable file_content. Hace llamar el método askopenfilename del módulo filedialog de tkinter y se proporcionan argumentos para los tipos de archivos válidos, en nuestro caso binario y de texto. En caso de que se encuentre el archivo, este se abre con la funcion open de Python en modo escritura y con codificación utf-8, se extrae el contenido del archivo en la variable file_content y si el archivo tiene extensión binaria, se habilita el botón de decompresion, por otra parte si el archivo es de extensión de texto, se utiliza otro método auxiliar para contar los caracteres.
El método de conteo de caracteres se encarga de generar (o sobrescribir) el diccionario de caracteres, este itera en cada carácter del archivo y registra cada carácter como una llave del diccionario, y aumentar el valor de cada llave en 1 por cada incidencia del carácter que se encuentre en el archivo. Seguido de esto se ordena el diccionario en base a las incidencias de caracteres, es decir, se muestran primero los caracteres que mas se repiten a lo largo del texto, se actualizar el widget de texto con el contenido del diccionario y finalmente se habilita el botón de compresión.
Eso seria todo por parte del front-end, para implementar un back-end solo se deberían importar funciones compression y decompression que reciban un diccionario y un string respectivamente, esto es opcional claro, si se requiere hacer cambios a esto se debería cambiar el comando de los botones de la interfaz en las líneas 67 y 71 del código para ajustar el nombre de la función o los argumentos que se proveen a esta.
Nota: El lambda en dichas líneas de código (donde se crean los botones y se establece la acción que realizaran al ser presionados, en este caso, hacer llamado de las funciones descomprimir y comprimir) se recomienda que se mantenga ya que en caso contrario no funciona correctamente, esto debido a ciertos comportamientos indefinidos al inicializarse las funciones y proveer argumentos que aun no se han definido correctamente, si se remueve, los botones no harán llamado a la función asociada una vez se hayan incializado.
